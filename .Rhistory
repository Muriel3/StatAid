# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
usethis::use_testthat()
use_test()
usethis::use_test()
## Run checks ----
## Check the package before sending to prod
devtools::check()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
descriptive_table <- function(data, group, na.include = F, percent_type = 1, padj_method = "none", show_methods = F,
exclude_vector = c("Patient_id", "patient_id", "Sample_ID")) {
## Change: Welch test!
if (group == "Whole_cohort") {
## Filter out var with >80% NA
na_var <- colnames(data)[colSums(is.na(data)) >= 0.8 * nrow(data)]
if (length(na_var) > 0) {
message(paste0(length(na_var), " variables with >80% missing values were removed from the analysis "))
}
var_num <- colnames(data[sapply(data, class) %in% c("numeric", "integer", "double")])
var_num <- var_num[!var_num %in% c(exclude_vector, na_var)]
var_cat <- colnames(data[sapply(data, class) %in% c("factor", "character")])
var_cat <- var_cat[!var_cat %in% c(exclude_vector, na_var)]
########## ========== Variables numériques
list_num <- list()
for (v in var_num) {
##### ===== DF
{
df <- data.frame(variable = data[, v])
colnames(df)[1] <- "variable"
}
##### ===== Mean (sd) and Median (IQR)
temp <- df %>%
summarise(
"Mean (sd)" = paste0(round(mean(variable, na.rm = T), 2), " (", round(sd(variable, na.rm = T), 2), ")"),
"Median [IQR]" = paste0(
round(median(variable, na.rm = T),2), " [",
round(median(variable, na.rm = T) - IQR(variable, na.rm = T), 2), "-",
round(median(variable, na.rm = T) + IQR(variable, na.rm = T), 2), "]"
)
)
##### ===== Mise en forme résultats
{
merged_results <- data.frame("Whole cohort" = t(temp), check.names = F) %>%
rownames_to_column("Type")
merged_results[1, "Variable"] <- v
merged_results <- select(merged_results, "Variable", everything())
}
list_num[[v]] <- merged_results
}
########## ========== Variables cat
list_cat <- list()
for (v in var_cat) {
##### ===== DF
{
df <- data.frame(variable = data[, v])
colnames(df)[1] <- "variable"
if (na.include == T) {
df <- df %>% mutate_if(is.factor,
fct_explicit_na,
na_level = "NA"
)
} else {
df <- df %>% filter(is.na(variable) == F)
}
}
##### ===== Contingency tables
table <- table(df)
frequencies <- round((prop.table(table) * 100), 2)
levels <- nlevels(factor(df$variable))
table_freq <- data.frame(cbind(table, frequencies))
##### ===== Mise en forme résultats
{
merged_results <- table_freq %>%
rownames_to_column("Type") %>%
transmute(
Type = Type,
"Whole cohort" = paste0(table, " (", table_freq$frequencies, ")")
)
merged_results[1, "Variable"] <- v
merged_results <- select(merged_results, "Variable", everything())
}
list_cat[[v]] <- merged_results
}
########## ========== Final df
final_df <- bind_rows(list_num, list_cat)
} else {
## Filter out var with >80% NA
na_var <- colnames(data)[colSums(is.na(data)) >= 0.8 * nrow(data)]
if (length(na_var) > 0) {
message(paste0(length(na_var), " variables with >80% missing values were removed from the analysis "))
}
var_num <- colnames(data[sapply(data, class) %in% c("numeric", "integer", "double")])
var_num <- var_num[!var_num %in% c(exclude_vector, na_var)]
var_cat <- colnames(data[sapply(data, class) %in% c("factor", "character")])
var_cat <- var_cat[!var_cat %in% c(exclude_vector, group, na_var)]
########## ========== Variables numériques
list_num <- list()
for (v in var_num) {
##### ===== DF
{
df <- data[, c(group, v)]
colnames(df) <- c("group", "variable")
df$group <- factor(df$group)
if (na.include == T) {
df <- df %>% mutate_if(is.factor,
fct_explicit_na,
na_level = "NA"
)
} else {
df <- df %>% filter(is.na(group) == F)
}
}
##### ===== Mean (sd) and Median (IQR)
temp <- df %>%
group_by(group) %>%
summarise(
"Mean (sd)" = paste0(round(mean(variable, na.rm = T), 2), " (", round(sd(variable, na.rm = T), 2), ")"),
"Median [IQR]" = paste0(
median(variable, na.rm = T), " [", round(median(variable, na.rm = T) - IQR(variable, na.rm = T), 2), "-",
round(median(variable, na.rm = T) + IQR(variable, na.rm = T), 2), "]"
)
) %>%
column_to_rownames("group")
##### ===== Statistics
{
if (nlevels(df$group) == 2) {
param <- t.test(df$variable ~ df$group, paired = F)
non_param <- wilcox.test(df$variable ~ df$group, paired = F)
} else {
param <- anova(lm(df$variable ~ df$group))
non_param <- kruskal.test(df$variable, df$group)
}
}
##### ===== Mise en forme résultats
{
merged_results <- data.frame(t(temp), check.names = F) %>%
rownames_to_column("Type")
## Ajout ligne NA
if (na.include == T) {
N_NA <- df %>%
group_by(group) %>%
summarise("NA n (%)" = paste0(sum(is.na(variable)), " (", round(sum(is.na(variable)) * 100 / n(), 2), ")")) %>%
column_to_rownames("group") %>%
t() %>%
data.frame(check.names = F) %>%
rownames_to_column("Type")
merged_results <- rbind(merged_results, N_NA)
}
merged_results[1, "Variable"] <- v
merged_results[1, "param_pvalue"] <- ifelse(nlevels(df$group) > 2, param$`Pr(>F)`[1], param$p.value)
merged_results[1, "param_method"] <- ifelse(nlevels(df$group) > 2, "ANOVA", param$method)
merged_results[1, "non_param_pvalue"] <- non_param$p.value
merged_results[1, "non_param_method"] <- non_param$method
merged_results <- select(merged_results, "Variable", everything())
}
list_num[[v]] <- merged_results
}
########## ========== Variables cat
list_cat <- list()
for (v in var_cat) {
##### ===== DF
{
df <- data[, c(group, v)]
colnames(df) <- c("group", "variable")
df$group <- factor(df$group)
if (na.include == T) {
df <- df %>% mutate_if(is.factor,
fct_explicit_na,
na_level = "NA"
)
} else {
df <- df %>% filter(is.na(group) == F)
}
}
##### ===== Contingency tables
table <- table(df)
frequencies <- round((prop.table(table, percent_type) * 100), 2) ## Col percentage
group_levels <- levels(df$group)
table_freq <- data.frame(cbind(table, frequencies))
mylist <- list()
for (nm in group_levels) {
temp <- data.frame(cbind(table[nm, ], frequencies[nm, ]))
temp[, 2] <- gsub("^", " (", temp[, 2])
temp[, 2] <- gsub("$", ") ", temp[, 2])
temp <- temp %>%
unite(nm, X1, X2, sep = "")
colnames(temp)[1] <- paste0(nm)
mylist[[nm]] <- temp
}
table_freq <- bind_cols(mylist)
rownames(table_freq) <- rownames(mylist[[1]])
##### ===== Statistics
{
param <- chisq.test(table)
non_param <- fisher.test(table, simulate.p.value = T)
}
##### ===== Mise en forme résultats
{
merged_results <- table_freq %>%
rownames_to_column("Type")
merged_results[1, "Variable"] <- v
merged_results[1, "param_pvalue"] <- param$p.value
merged_results[1, "param_method"] <- param$method
merged_results[1, "non_param_pvalue"] <- non_param$p.value
merged_results[1, "non_param_method"] <- gsub("for Count Data ", "", non_param$method)
merged_results[1, "non_param_method"] <- gsub("\\n.*$", "", merged_results[1, "non_param_method"])
merged_results <- select(merged_results, "Variable", everything())
}
list_cat[[v]] <- merged_results
}
########## ========== Final df
final_df <- bind_rows(list_num, list_cat)
}
final_df$Variable[is.na(final_df$Variable)] <- ""
if (group != "Whole_cohort") {
final_df$param_pvalue_adj <- final_df$param_pvalue
final_df$param_pvalue_adj[which(is.na(final_df$param_pvalue_adj) == F)] <- p.adjust(final_df$param_pvalue_adj[which(is.na(final_df$param_pvalue_adj) == F)], method = padj_method)
final_df$non_param_pvalue_adj <- final_df$non_param_pvalue
final_df$non_param_pvalue_adj[which(is.na(final_df$non_param_pvalue) == F)] <- p.adjust(final_df$non_param_pvalue[which(is.na(final_df$non_param_pvalue) == F)], method = padj_method)
pval_cols <- c("param_pvalue", "param_pvalue_adj", "non_param_pvalue", "non_param_pvalue_adj")
na_to_remove_cols <- c(pval_cols, "param_method", "non_param_method")
final_df[, pval_cols] <- apply(final_df[, pval_cols], 2, function(x) {
format.pval(x, 2)
})
final_df[, na_to_remove_cols][final_df[, na_to_remove_cols] == "NA"] <- ""
if (padj_method == "none") {
final_df <- final_df %>% select(-all_of("param_pvalue_adj"), -all_of("non_param_pvalue_adj"))
} else {
final_df <- final_df %>% select(-all_of("param_pvalue"), -all_of("non_param_pvalue"))
}
if (show_methods == F) {
final_df <- final_df %>% select(-all_of("param_method"), -all_of("non_param_method"))
}
}
return(final_df)
}
# Set options here
options(golem.app.prod = T) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
